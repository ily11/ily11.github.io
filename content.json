[{"title":"Linux下安装eclipse以及配置spring-tool-suite插件","date":"2017-09-29T03:38:38.000Z","path":"2017/09/29/Tool插件/","text":"Eclipse安装首先要安装JDK，网上的教程很多，我这里就不赘述了，大体步骤就是先解压然后配置环境变量、生效。下面详细说明eclipse的安装。 1、首先在官网下载相应版本的eclipse： eclipse-jee-oxygen-1-linux-gtk-x86_64.tar.gz 2、执行命令：1sudo tar zxvf eclipse-jee-oxygen-1-linux-gtk-x86_64.tar.gz -C /opt/jvm 将文件解压到/opt/jvm/下 3、创建eclipse桌面快捷方式图标。123cd 桌面sudo touch eclipse.desktopsudo gedit eclipse.desktop 然后在文本编辑器里输入以下内容：12345678910[Desktop Entry]Name=Eclipse 4Type=ApplicationExec=/opt/eclipse/eclipseTerminal=falseIcon=/opt/eclipse/icon.xpmComment=Integrated Development EnvironmentNoDisplay=falseCategories=Development;IDE;Name[en]=Eclipse 保存。 执行:sudo chmod u+x eclipse.desktop 将其变为可执行文件. 4、在桌面打开eclipse，会提示未信任的应用程序启动器。此时的解决方案是：打开终端，输入sudo nautilus，nautilus这个命令是用于以root权限打开文件管理窗口。在打开的文件管理窗口找到桌面的“eclipse.desktop”，然后右击【属性】，勾选“允许作为程序执行文件”，如图所示：然后再点击文件即可运行。 Eclipse上安装spring-tool-suitespring tool suite 是一个基于eclipseIDE开发环境中的用于开发spring应用程序的工具。 1、首先查看自己安装的eclipse版本，打开eclipse-&gt;Help-&gt;about eclipse，可以看到我的是4.7.1：2、登录https://spring.io/tools/sts/all，找到相应版本的spring tool suite并复制地址:3、Help–&gt;Install New Software–&gt;work with 中输入 http://dist.springsource.com/release/TOOLS/update/e4.7/ ,回车等待片刻，然后按照下图选择选项，去掉自动更新，然后选择next,然后一路next，出现接受协议的选择接受。 4、安装完成后会提示重启，重启后，Spring IDE出现在欢迎界面：安装成功。","tags":[{"name":"eclipse spring","slug":"eclipse-spring","permalink":"http://summer.com/tags/eclipse-spring/"}]},{"title":"Angular2 学习","date":"2017-09-19T03:40:41.000Z","path":"2017/09/19/Angular2-学习/","text":"TypeScript基本类型在TypeScript中主要有以下基本数据类型： 布尔类型（boolean） 数字类型（number） 字符串类型（string） 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意值类型（any） null和undefined void类型 never类型其中元组、枚举、任意值、void类型和never类型是TypeScript有别于JavaScript的特有类型。 元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同。示例代码如下：123let x:[string,number];x = [&apos;Angular&apos;,25]; //运行正确x = [25,&apos;Angular&apos;]; //运行出错 never类型是其他类型（包括null和undefined）的子类型，代表从不会出现的值。这意味着声明为never类型的变量只能被never类型所赋值。 解构所谓解构，就是将声明的一组变量与相同结构的数组或者对象的元素数值一一对应，并将变量相对应元素进行赋值。解构可以帮助开发者非常容易地实现多返回值的场景。 数组解构1234let input = [1,2];let [first,second] = input;console.log(first); //相当于input[0]:1console.log(second); //相当于input[1]:2 还可以在数组解构中使用rest参数语法（形式为“…变量名”）创建一个剩余变量列表，“…”三个连续小数点表示展开操作符，用于创建可变长的参数列表，实例代码如下：123let [first,...rest] = [1,2,3,4];console.log(first); //输出1console.log(rest); //输出[2,3,4] 对象解构对象解构有趣的地方是一些原本需要多行编写的代码，用对象解构的方式编写一行代码就能完成，代码很简洁，可读性强：123let test = &#123;x:0,y:10,width:15,height:20&#125;;let &#123;x,y,width,height&#125; = test;console.log(x,y,width,height); //输出0，10，15，20 函数可选参数在TypeScript里，被调函数的每个参数都是必传的：1234567function max(x:number,y:number):number&#123; return x&gt;y?x:y;&#125;let result1 = max(2); //报错let result2 = max(2,4); // 正确let result3 = max(2,4,7); // 报错 但是经常会遇到要根据实际需要来决定是否传入某个参数的情况，这时候可在参数名旁边加上?来使其变为可选参数：1234567891011function max(x:number,y?:number):number&#123; if(y)&#123; return x&gt;y?x:y; &#125;else&#123; return x; &#125;&#125;let result1 = max(2); //正确let result2 = max(2,4); // 正确let result3 = max(2,4,7); // 报错 注：可选参数必须位于必选参数的后面 默认参数TypeScript还支持初始化默认参数。如果函数的某个参数设置了默认值，当该函数被调用的时候，如果没有给这个参数传值或者传的值为undefined时，这个参数的值就是设置的默认值：12345678function max(x:number,y=4):number&#123; return x&gt;y?x:y;&#125;let result1 = max(2); //正确let result2 = max(2,4); // 正确let result3 = max(2,4,7); // 报错let result4 = max(2,undefined); //正确 带默认值的参数不必放在必选参数的后面，但如果默认值参数放在了必选参数的前面，用户必须显式地传入undefined:12345678function max(x=2,y:number):number&#123; return x&gt;y?x:y;&#125;let result1 = max(2); //报错let result2 = max(2,4); // 正确let result3 = max(2,4,7); // 报错let result4 = max(undefined,4); // 正确 剩余参数上面说的可选参数、必选参数和默认参数只能表示某一个参数，当同时需要操作多个参数的时候，就需要用到TypeScript里的剩余参数。在TypeScript里，所有的可选参数都可以放到一个变量里，示例代码如下：123456789function sum(x:number,...restOfNumber:number[]):number&#123; let result = x; for(let i=0;i&lt;restOfNumber.length;i++)&#123; result += restOfNumber[i]; &#125; return result;&#125;let result = sum(1,2,3,4,5);console.log(result); //输出15 注：剩余参数可以理解为个数不限的可选参数，即剩余参数包含的参数个数可以为零到多个 组件组件生命周期组件的生命周期由angular内部管理，从组件的创建、渲染，到数据变动时间的触发，再到组件从DOM移除，Angular都提供来一系列钩子，以下是组件常用的生命周期钩子方法，Angular会按以下的顺序依次调用： ngOnChanges ngOnInit ngDoCheck ngAfterContentInit ngAfterContentChecked ngAfterViewInit ngAfterViewChecked ngOnDestroy ngOnChanges它是用来响应组件输入值发生变化时触发的事件。该方法接收一个SimpleChanges对象，包括当前值和变化前的值。该方法在ngOnInit之前，或者当数据绑定输入属性的值发生变化时触发。 只要在组件里定义来ngOnChanges方法，在输入数据发生变化时该方法就会被自动调用，这里的“输入数据”指的是通过@Input装饰器显式指定的那些变量。 ngOnInitngOnInit钩子用于数据绑定输入属性之后初始化组件。在组件中，经常会使用ngOnInit获取数据。使用ngOnInit有以下两个原因： 组件构造后不久就要进行复杂的初始化 需要在输入属性设置完成后才构造组件 在第一轮 ngOnChanges 完成之后调用。 ( 译注：也就是说当每个输入属性的值都被触发了一次 ngOnChanges 之后才会调用 ngOnInit ，此时所有输入属性都已经有了正确的初始绑定值 ) ngDoCheck用于变化监测，该方法会在每次变化监测发生时被调用。 绝大多数情况下，ngDoCheck和ngOnChanges不应该一起使用。ngOnChanges能做的事情，ngDoCheck也能做到，而且ngDoCheck监测的粒度更小，可以完成更灵活的变化监测逻辑。 ngAfterContentInit在组件中使用将外部内容嵌入到组件视图后就会调用ngAfterContentInit，它在第一次ngDoCheck执行后调用，且只执行一次。当把内容投影进组件之后调用。 ngAfterContentChecked在组件中使用自定义内容的情况下，Angular在这些外部内容嵌入到组件视图后，或者每次变化监测的时候都会调用ngAfterContentChecked。每次完成被投影组件内容的变更检测之后调用。 ngAfterViewInit初始化完组件视图及其子视图之后调用。 会在Angular创建了组件的视图及其子视图后被调用。 ngAfterViewChecked每次做完组件视图和子视图的变更检测之后调用。 在Angular创建了组件的视图及其子组件视图之后被调用一次，并且在每次子组件变化监测时也会被调用。 ngOnDestroy当 Angular 每次销毁指令 / 组件之前调用。","tags":[{"name":"Angular","slug":"Angular","permalink":"http://summer.com/tags/Angular/"}]},{"title":"CSS 之position和transition","date":"2017-06-22T08:12:38.000Z","path":"2017/06/22/CSS-之position和transition/","text":"","tags":[{"name":"CSS","slug":"CSS","permalink":"http://summer.com/tags/CSS/"}]},{"title":"Canvas 学习之绘制图形","date":"2017-03-22T03:19:31.000Z","path":"2017/03/22/Canvas-画图/","text":"最近在学习《HTML5 Canvas游戏开发实战》这本书，现整理一下，以便后面翻出来复习。 基本图形圆角矩形先贴出代码和运行效果123456789101112131415&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(40,20); ctx.lineTo(100,20); ctx.arcTo(120,20,120,40,20); ctx.lineTo(120,70); ctx.arcTo(120,90,100,90,20); ctx.lineTo(40,90); ctx.arcTo(20,90,20,70,20); ctx.lineTo(20,40); ctx.arcTo(20,20,40,20,20); ctx.stroke();&lt;/script&gt; 运行效果如下图：下面来解释一下代码：Canvas里没有直接画圆角矩形的API，但是可以用arcTo函数来完成圆角的绘制，然后结合直线绘制，就可以完成圆角矩形的绘制了。arcTo函数是用来为当前的子路径添加一条圆弧的，它需要5个参数，分别是：点p1的坐标x和y、点p2的坐标x和y、圆弧的半径。该圆弧有一点与当前位置到p1的线段相切，还有一点和从p1到p2的线段相切。这两个切点就是圆弧的起点和终点，圆弧绘制的方向就是连接这两个点的最短圆弧方向。 擦除Canvas画板擦除Canvas画板上的内容需要用到clearRect函数，此函数可以擦除一个矩形区域。它需要四个参数：起点的坐标x和y，擦除区域的长和宽。代码如下：12345678&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;red&quot;; ctx.beginPath(); ctx.fillRect(10,10,200,100); ctx.clearRect(30,30,50,50);&lt;/script&gt; 上述代码是先绘制了一个红色的实心矩形，然后在红色矩形内擦除了一个50*50的小正方形，运行效果如下图所示： 绘制复杂图形画曲线#####二次贝塞尔曲线二次贝塞尔曲线有一个控制点。在Canvas中用quadraticCurveTo(cpx,cpy,x,y)函数来绘制二次贝塞尔曲线，cpx、cpy表示控制点的坐标；x、y表示终点坐标。其代码如下：1234567var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.moveTo(100,100); //绘制二次贝塞尔曲线 ctx.quadraticCurveTo(20,50,200,20); ctx.stroke(); 效果图如下： 利用clip在指定区域绘图clip函数使用当前路径作为连续绘制操作的剪切区域。我们可以把它看作一扇窗户，无论在画板上绘制了多大的图形，最后看到的图形都只能由clip这个窗户来决定。代码如下：123456789101112&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); //绘制半圆 ctx.arc(100,100,40,0,180 * Math.PI/180,true); ctx.clip(); ctx.beginPath(); //设置颜色 ctx.fillStyle = &quot;lightblue&quot;; //绘制矩形 ctx.fillRect(0,0,300,150);&lt;/script&gt; 效果图如下：可以看到，虽然我们画了一个矩形，但是最后显示的却是一个半圆。这是因为我们我们首先画了一个半圆，然后clip函数将当前的这个半圈作为绘制操作的区域，所以之后画的图形只能显示在这个区域内。 绘制文本绘制文字绘制文字有fillText和strokeText两种方法。1、使用fillText绘制文字fillText(text,x,y,maxWidth)函数很简单，它有四个参数：文本字符串、坐标x和y，文本宽度，其中第四个参数可以略去。实例代码如下：12345678&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); //设置文字大小和字体 ctx.font = &quot;30px Arial&quot;; //设置文字内容 ctx.fillText(&quot;Hello World&quot;,100,50);&lt;/script&gt; 运行效果如下图所示：2、使用strokeText绘制文字使用strokeText(text,x,y,maxWidth)函数同样需要4个参数，它的用法和fillText函数用法完全相同，具体代码如下：12345678&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); //设置文字大小和字体 ctx.font = &quot;30px Arial&quot;; //设置文字内容 ctx.strokeText(&quot;Hello World&quot;,100,50);&lt;/script&gt; 效果图如下：从效果图上我们可以看出strokeText与fillText的区别是，strokeText相当于是线，而fillText相当于实心图形。 文字设置1、文字大小与字体上面的代码中用到了ctx.font = &quot;30px Arial&quot;;它设置了字体大小为“30px”，字体为“Arial”。我们可以设定多种不同的字体、大小，代码如下：12345678910111213141516171819202122232425262728&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.beginPath(); //设置文字大小为30px ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,50); ctx.beginPath(); //设置文字大小为50px ctx.font = &quot;50px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,150); ctx.beginPath(); //设置文字大小为70px ctx.font = &quot;70px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,250); ctx.beginPath(); //设置文字字体为Verdana ctx.font = &quot;30px Verdana&quot;; ctx.fillText(&quot;Hello World (Verdana)&quot;,50,300); ctx.beginPath(); //设置文字字体为Times New Roman ctx.font = &quot;30px Times New Roman&quot;; ctx.fillText(&quot;Hello World (Times New Roman)&quot;,50,350); ctx.beginPath(); //设置文字字体为Courier New ctx.font = &quot;30px Courier New&quot;; ctx.fillText(&quot;Hello World (Courier New)&quot;,50,400);&lt;/script&gt; 效果图如下：2、文字粗体与斜体同样可以通过font来设置文字粗体和斜体，如粗体：ctx.font = &#39;normal 30px Arial&#39;;font-weight可以是normal、bold、bolder、lighter，还可以通过数字直接设置，如ctx.font = &#39;300 30px Arial&#39;;。斜体可以这样设置：ctx.font = &#39;italic 30px Arial&#39;;。效果图就不一一展示了。3、文字的对齐方式Canvas中的文字通过textAlign和textBaseline来实现文字的对齐。textAlign是水平方向的文字对齐，它的值包括center、end、left、right、start。textBaseline是竖直方向的文字对齐，它的值包括alphabetic、bottom、ideographic、middle、top。首先看水平方向的对齐。为了看出对齐方式之间的区别，我们在文字坐标位置画一条竖线，代码如下：12345678910111213141516171819202122232425262728293031&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(160,0); ctx.lineTo(160,300); ctx.stroke(); ctx.beginPath(); ctx.textAlign = &quot;start&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,160,50); ctx.beginPath(); ctx.textAlign = &quot;end&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,160,100); ctx.beginPath(); ctx.textAlign = &quot;center&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,160,150); ctx.beginPath(); ctx.textAlign = &quot;left&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,160,200); ctx.beginPath(); ctx.textAlign = &quot;right&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,160,250);&lt;/script&gt; 效果图如下：从效果图上可以看出，start与left相同，表示文字从左侧开始对齐；end与right相同，表示文字从右侧开始对齐，center表示文字居中。下面看一下竖直方向的对齐，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.textBaseline = &quot;alphabetic&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,50); ctx.moveTo(0,50); ctx.lineTo(250,50); ctx.stroke(); ctx.textBaseline = &quot;bottom&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,100); ctx.moveTo(0,100); ctx.lineTo(250,100); ctx.stroke(); ctx.textBaseline = &quot;hanging&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,150); ctx.moveTo(0,150); ctx.lineTo(250,150); ctx.stroke(); ctx.textBaseline = &quot;ideographic&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,200); ctx.moveTo(0,200); ctx.lineTo(250,200); ctx.stroke(); ctx.textBaseline = &quot;middle&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,250); ctx.moveTo(0,250); ctx.lineTo(250,250); ctx.stroke(); ctx.textBaseline = &quot;top&quot;; ctx.font = &quot;30px Arial&quot;; ctx.fillText(&quot;Hello World&quot;,50,300); ctx.moveTo(0,300); ctx.lineTo(250,300); ctx.stroke();&lt;/script&gt; 效果图如下： 图片操作Canvas中提供了drawImage函数和putImageData函数来绘制图片。 利用drawImage绘制图片drawImage函数有3种函数原型，其语法如下：drawImage(image,dx,dy);drawImage(image,dx,dy,dw,dh);drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);第一个参数image是要绘制的对象，这个参数可以是HTMLImageElement、HTMLCanvasElement或者HTMLVideoElement，dx、dy是image在Canvas中定位的坐标值，dw、dh表示image在Canvas中即将绘制的区域（相对dx、dy坐标的偏移量）的宽度和高度值，sx、sy是image所要绘制的起始位置，sw、sh表示image所要绘制区域（相对于image的sx、sy坐标的偏移量）的宽度和高度值。代码如下：12345678910111213141516171819&lt;body&gt;img标签&lt;br&gt;&lt;img id=&quot;home&quot; src=&quot;image/22.png&quot; width=&quot;240&quot; height=&quot;240&quot;&gt;&lt;br&gt;Canvas画板&lt;br&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;600&quot; style=&quot;border: 1px&quot; height=&quot;350&quot;&gt; 您的浏览器不支持Canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;image/22.png&quot;; image.onload = function () &#123; ctx.drawImage(image,10,10); ctx.drawImage(image,410,10,100,100); ctx.drawImage(image,50,50,100,100,410,130,100,100); &#125;;&lt;/script&gt; 效果图展示：从图中可以看出Canvas画板里的右上小图是原图的缩小，而右下小图是左边大图截取的一部分（图中标注部分）。 利用getImageData和putImageData绘制图片putImageData（imgdata,dx,dy,sx,sy,sw,sh）函数需要7个参数，其中imgdata为像素数据，dx、dy是绘制图片的定位坐标值，sx、sy是imgdata所要绘制图片的起始位置，sw、sh是imgdata所要绘制区域（相对于imgdata的sx和sy坐标的偏移量）的宽度和高度值。这里面第4个参数以及其后的所有参数都可以省略，如果这些参数都省略了，则表示绘制整个imgdata。在使用putImageData之前，需要先用getImageData(x,y,w,h)函数得到像素数据，这里只得是从Canvas画板上取得所选区域的像素数据，它的四个参数分别是选择区域起点坐标x、y，选择区域的长和宽。代码如下：123456789101112&lt;script&gt; var c = document.getElementById(&quot;myCanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); var image = new Image(); image.src = &quot;image/22.png&quot;; image.onload = function () &#123; ctx.drawImage(image,10,10); var imgData = ctx.getImageData(50,50,200,200); ctx.putImageData(imgData,10,260); ctx.putImageData(imgData,200,260,50,50,100,100); &#125;;&lt;/script&gt; 效果图如下：","tags":[{"name":"canvas","slug":"canvas","permalink":"http://summer.com/tags/canvas/"}]},{"title":"【转载】知人不评人，是一个人最基本的修养","date":"2017-02-28T08:54:54.000Z","path":"2017/02/28/知人不评人，是一个人最基本的修养/","text":"看到一篇文章《知人不评人，是一个人最基本的修养》，在生活中，我们总是去评价别人的生活，“这人怎么这样呢，太不合群了”、“她条件这么好怎么会看上他呢”等等等等，包括我，我就觉得我这一点不好，看不惯的总是要说上几句，其实，想想，别人的生活，自己生活的好就好，你又不是他，怎么会了解人家的感觉，所以说，不评价别人也是一种修养，特此，转载此文章来惊醒自己，提高自己的修养。 【转】01看到一个故事： 一对英国的小夫妻没什么钱，结婚前，跑进一个珠宝店，这家珠宝店据说价格很低，130美元就可以订一个戒指。130美元的戒指当然是买不到克拉钻的，只要是男人买的戒指，锆石、银戒对女人来说并不是什么大问题。结果，当女人在店里试戴戒指的时候，店员对她说，“简直不敢相信有男人会用这么便宜的戒指来结婚，太悲哀了。”结果，这段经历就被放到了网上。 那个女孩说，结婚并不一定需要上万的钻戒和兴师动众的仪式。 事情的结局是，女孩嫁给了那个男孩。而珠宝店也做了道歉。 我想起一句话，不要用你自己的眼光随便去评价别人的生活，因为你根本不懂别人的幸福。 02我们总是有一种习惯，把自己眼中的幸福，定义为别人身上的幸福。于是以为别人不够幸福，不够好，不够完美，也配不上所拥有的一切。 可是，你不是她，又怎知他们的喜怒哀乐。抑或许，在你眼中的幸福，在她的眼中不过是一文不值而已。 不评价别人的生活，因为生活不是你的；不操心别人的生活，是因为别人的路由他们选择。 我们中的许多人，也常常打着“为你好”“也希望你幸福”，算你也是真心实意的，可是在别人死了心，决定在自己的生活里安心享受一切的时候，最大的爱意，莫过于，不评价，也祝福他们的幸福。 而不评价别人的生活，也是一种最基本的素养。 03以前学习的时候，班上总有这样的同学，学习特别用功，成绩却总是平平。比如老幺。 老幺是那种很刻苦的女孩子，上课的时候，她总是很认真地听课；我们下课在玩耍的时候，她还是在做题；我们所有人自修结束去食堂买夜宵，她非得挨到值班老师来叫她了，她才走；我们所有人熄灯睡觉的时候，她还是照着手电筒，在被窝里读书。 可是，所有经历过学生时代的人都知道，很多时候，我们努力学习，只会比不努力的自己学习好一点，但未必比其他不努力的同学优秀。 于是，总有那么一些人在背后说：你看看她，如果我是她，才不想那么认真，永远是中游水平，一点指望都没有。当然，一些好学生也很漠然，她们总是有意无意地表现出优越感，说，不是所有认真都可以有成绩的，还是得先天。 老幺也不管。我不算她的好朋友，但算是关系还可以的同学。其实，听到有人说老幺，内心也会有点悲凉和愤怒：悲凉是老幺这么努力却始终没有得到她所得到的好成绩；愤怒，大概是作为学生时代的我们，最大的讽刺，就是被人说是那个不聪明的孩子，而这一切，大概也真的与人无关吧。 老幺后来发过一次飚，是因为一个男生得意洋洋地跑到她面前，说，你看努力也没用。还不是不及格？我也不及格。 那一次物理很难吧，很多人都挂科了，包括老幺。 老幺站起来，她很平静地站在那个男生面前：我努力学习是得罪你了吗？你有什么资格评论别人。我今天是挂科了，但我就是喜欢努力，我觉得问心无愧。 老幺说得很有底气，若干年后，她成了一个单位的HR，专业培训员工，她说，她对每一个认真的员工都保有最深的敬意，对每一个人的生活都绝对的尊重。 “那年的事，其实对我改变挺大的。一直到现在，工作之外，我都不会去随便评价任何一个人的生活。因为每个人对自己的生活方式有自己的定义。一个人最大的恶意，就是把自己的理解强加于别人，把所有的结果理所当然用自己的过程来解释，并一直认为自己是正确的。” 04不评价别人是一种修养，不理会别人的评价是一种修行。 感情生活和日常生活，都是如此。 我常常听到这样的交谈，诸如“你看，她年纪那么大了，不知道为什么还不肯嫁？”“你看她条件那么好，为什么跟了这样的人”，我很想问问他们，“别人的生活，你到底多有资格评价？” 我的闺蜜结婚的时候，所有人都不看好。在大家眼中，她是那个即将跨入白富美的人，可是偏偏嫁给了一个根本就买不起房子、也买不起车子的人。 她父母倒是开明。可许多亲戚不理解，有些人说，这是脑子发昏了才会有这样的结果。邻居更是七嘴八舌地议论，认为她是不听别人劝，以后就危险了。 闺蜜虽然心烦，可是她看得开。如今，和自己的先生一起创业，倒也挣得了房子，买了车子。 有一次，闺蜜和我说，“有人问我，如果现在没买房子也没买车子，该怎么办？我说，最差也差不过当年，既然当年都能在一起，现在为什么不可以呢？他们总觉得我会不幸，我觉得，幸福的感觉都是自己的，与别人无关。” 05其实，别人过得好不好，选择怎样的生活，都是别人的选择。 你看得惯也好，看不惯也好，也是别人的生活。 总有人说，你得强大啊，强大到忽略别人而已。可是，别人能不能忽略你的评价是别人的事，而你不评价别人，是你的教养。 每个人都有自己的牧羊犬，也有自己的故事体，每个人都有自己的方向，也请拜托，别去远方指着别人的路，让别人糟心不已。 不评价别人的生活，是一个人最基本的素养。 毕竟你有你的人生要过，别人也有别人的日子要走。 ◆作者简介：谢可慧，专栏作家，新浪微博@谢可慧的村庄，公众号：秋小愚。新书《干得漂亮是能力，活得漂亮是本事》已经火热上市，本文经授权发布。文章原标题《不评价别人的生活，是一个人最基本的修养》。","tags":[{"name":"修养","slug":"修养","permalink":"http://summer.com/tags/修养/"}]},{"title":"bootbox.js弹框","date":"2017-02-26T03:44:00.000Z","path":"2017/02/26/bootbox-js弹框/","text":"最近用bootbox做弹出框的时候遇到了一个问题，就是如何获取弹出框dialog里文本输入的内容。刚开始，我自以为是的给text和textarea设置id，根据id获取其值，然而失败了，先把代码贴上来吧：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-12&quot; style=&quot;margin: 20px&quot;&gt; &lt;button id=&quot;Dialog&quot;&gt;Dialog&lt;/button&gt; &lt;button id=&quot;Alert&quot;&gt;Alert&lt;/button&gt; &lt;button id=&quot;Confirm&quot;&gt;Confirm&lt;/button&gt; &lt;button id=&quot;Promp&quot;&gt;Prompt&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;dialogModel&quot; style=&quot;display: none&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;span&gt; 活动名称： &lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot; placeholder=&quot;请输入活动名称&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;span&gt; 活动描述： &lt;/span&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;desc&quot; placeholder=&quot;请输入活动描述&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function () &#123; $(&quot;#Dialog&quot;).on(&quot;click&quot;,function () &#123; bootbox.dialog(&#123; message:$(&quot;#dialogModel&quot;).html(), title:&quot;创建活动&quot;, className:&quot;modal-blue&quot;, buttons:&#123; success:&#123; label:&quot;确定&quot;, className:&quot;btn-blue&quot;, callback:function () &#123; var name = $(&quot;#name&quot;).val(); var desc = $(&quot;#desc&quot;).val(); alert(name +&quot; &quot;+desc); &#125; &#125;, cannel:&#123; label:&quot;取消&quot;, className:&quot;btn-default&quot;, callback:function () &#123; &#125; &#125; &#125; &#125;) &#125;) &#125;)&lt;/script&gt; 弹出的效果如下，alert出来的是空：多次查找无果后，请教了师兄，师兄说不能用Id来获取值的，因为我在页面写的id=”dialogModel”这一块代码是在弹出对话框时填充到对话框里的message里的，这样的话就有两个id都是“name”的text和两个”id=’desc’”的textarea了，用id肯定是取不出来值的，因为目前只有一个弹出框，所以下图标注的”class=’modal-dialog’”肯定是唯一的，可以通过这个来找到值：修改代码如下：首先将text和textarea的id去了，然后将确定里的回调函数取值方式修改，值贴出回调函数的修改代码：123456789101112131415161718buttons:&#123; success:&#123; label:&quot;确定&quot;, className:&quot;btn-blue&quot;, callback:function () &#123; var name = $(&quot;.modal-dialog .bootbox-body input[type=&apos;text&apos;]&quot;).val(); var desc = $(&quot;.modal-dialog .bootbox-body textarea&quot;).val(); alert(name +&quot; &quot;+desc); &#125; &#125;, cannel:&#123; label:&quot;取消&quot;, className:&quot;btn-default&quot;, callback:function () &#123; &#125; &#125;&#125; 此时就获取到文本框里的值了：下面就附带着整理一下bootbox的几种弹框方式，以便后面使用时查找。 Dialogdialog弹框就像上面写的那样，先把要弹出的内容写出来，一般写在页面的最后，然后就是bootbox.dialog({})里面配置dialog的title、message（就是将刚刚写的要弹出的内容填充进来）、className（可以引用自己写的样式，用beyongAdmin的话是有自己封装好的样式的，可以直接引用）、buttons（设置按钮显示文字以及样式、回调函数等）… Alertalert就是弹出提示信息的，只有一个确定按钮12345678910$(&quot;#alert&quot;).on(&quot;click&quot;,function () &#123; bootbox.alert(&#123; size: &quot;small&quot;, title: &quot;提示信息&quot;, message: &quot;活动描述不少于10个字！&quot;, callback: function()&#123; &#125; &#125;)&#125;) 效果图如下： Confirmconfirm是有两个按钮：取消和确定，主要是询问是否要做一件事的123456789101112$(&quot;#Confirm&quot;).on(&quot;click&quot;,function () &#123; bootbox.confirm(&#123; size: &quot;small&quot;, message: &quot;Are you sure?&quot;, callback: function(result)&#123; /* result is a boolean; true = OK, false = Cancel*/ if(result)&#123; //点击“确定”要操作的 &#125; &#125; &#125;)&#125;) 效果如下： PromptPrompt是让你输入信息后选择确定还是取消，它的设置没有message但是需要有title：1234567$(&quot;#Promp&quot;).on(&quot;click&quot;,function () &#123; bootbox.prompt(&#123; size: &quot;small&quot;, title: &quot;What is your name?&quot;, callback: function(result)&#123; /* result = String containing user input if OK clicked or null if Cancel clicked */ &#125; &#125;)&#125;) 效果如下：也可以把文本框换成别的，textarea, email, select, checkbox, date, time, number, and password等，只要修改配置inputType即可。以上弹出的都是英文，可以在bootbox.dialog之前加上bootbox.setLocale(&quot;zh_CN&quot;);，弹出的即是中文的，当然现在的按钮默认的是“确定”和“取消”，你也可以自定义按钮显示的文字，可以通过12345678910111213141516buttons:&#123; success:&#123; label:&quot;是&quot;, className:&quot;btn-blue&quot;, callback:function () &#123; &#125; &#125;, cannel:&#123; label:&quot;否&quot;, className:&quot;btn-default&quot;, callback:function () &#123; &#125; &#125;&#125; label来修改，当然这样子也可以直接将英文改成中文的，而不用加上面那句话了bootbox.setLocale(&quot;zh_CN&quot;);。","tags":[{"name":"bootstrap bootbox","slug":"bootstrap-bootbox","permalink":"http://summer.com/tags/bootstrap-bootbox/"}]},{"title":"【转载】你的善良里藏着自己的运气","date":"2017-02-23T03:52:06.000Z","path":"2017/02/23/你的善良里藏着自己的运气/","text":"我一直都坚信好人是有好报的，虽然你的善良不一定立马给你带来什么回报，但是善良会让你远离灾难，下面这篇文章是在微信公众号里看到的，感觉说的真的很不错，就拿来收藏一下。 01 2017年2月9日晚，河南新密一名叫陈奕帆的学生骑电动车不慎撞上了停在路边的一辆宝马车，由于车主不在现场，他便写了一封道歉信，然后用信封包着寒假打工赚来的311元钱卡在宝马车门把手里。此举让宝马车主薛先生大为感动，他向当地警方寻求帮助，希望找到这名学生，然后将钱还给对方。 后来，在警方的帮助下，薛先生找到了这名学生，当得知他品学兼优时，薛先生萌生了拿出一万元资助这位学生的想法，但被陈奕帆拒绝了，他说：“明明是我自己的错，人家不要求赔偿，我已经感到很内疚了，怎么好意思再要这钱呢？”后来，薛先生的二女儿说：“这钱是我父亲的心愿，也是他的承诺。再说，这钱是资助你学习的，如果你要赔车钱，可以等到你毕业赚了钱再说，这钱必须要收下。”在她的劝说下，陈奕帆才收下了这饱含情意的“助学金”。 一个勤工俭学的高中生，在出现事情时选了勇于担当，而促成这份担当的就是他的善良，所以人们经常说善良的人最好命。 在整个事情中，陈奕帆是幸运的，但是这份幸运并不是偶然的，这与他的本性有很大关系。如果当时出了事情，他选择悄无声息的逃避，良心的谴责肯定会让他这一生都坐立不安，更不用说得到充满温情的助学金了。古语说“人行善，福虽未至，但祸已远行”，这句话是非常有道理的。 善良不仅表现出一个人的本性，更表现出一个人的处事方式，越是善良的人，他们计较的东西越少，敢于承担的责任越多。时间久了，他们的人缘也会更好，生活自然也会变得更美好。 02单位小马是一个非常善良的人。前段时间，公司让他出差，在去目的地的路上钱被人骗了，由于我们两个私下关系还可以，他怕完不成任务就打电话让我给他汇点钱，后来才知道他的钱并不是被人骗了，而是被自己的善良劫持了。 刚上车没多久，有一个小伙子上来讨钱，哭着说自己的家里人生病了，求大伙帮帮忙，这时整个车上的人都无动于衷，当这个小伙子觉得没有指望时，小马竟然把整整2000块钱都给了他，嘴里还一直说：“虽然这钱我也要用，但救人要紧，先给你吧”。众人惊愕不已，当小伙子拿钱下车后，一名乘客说：“你不会是SB吧，这么明显的骗子，难道看不出来”？小马讪讪的说：“我觉得这是真的，如果真被骗了，我也认了，要是真的，最起码能在救人上尽一份微薄之力”。 后来，媒体报道了这件事情，结果还真像小马说的一样，那个小伙子当时确实是走头无路了，才想在车上碰碰运气，没想到真的找到了小马这么善良的人，从那之后他们成了好兄弟，小马生病缺钱，这位小伙子知道后，二话不说就给他打了一万块。小伙子说：“他在我最困难的时候帮助了我，现在到了我报恩的时候了。” 其实，善良里真的藏着一个人的运气，你在善良里投入的日后定会得到成倍的回报。 03去年，我采访了当地一位有名的企业家，当得知他曾经差点被对手置于死地时，我有些傻逼的说：“现在你雪耻的机会来了”。 他看了我一眼说：“小伙子，我为什么要雪耻？他（竞争对手）也过的不容易，前段时间公司差点破产，是我主动借给他钱才得以渡过难关”。看到我不解的样子，他继续说：“这个世界上，终究是善良的人多，当时他那么对我或许有自己的苦衷吧，我不能因为他而改变自己的善良，我始终相信一个人的善良里藏着自己的运气”。 当他说完这些话后，我突然对眼前这个人肃然起敬，也许在他的世界里根本没有雪耻的概念，有的只是单纯的善良，我想他之所以能东山再起，应该也是这份善良的功劳。 在《西游记》里，我想最恼人的应该就是唐僧的紧箍咒，明明是自己凡胎肉眼看不到妖怪，却用自己的眼光否定真实的事实。但我不明白，为何他身边的四个徒弟（包括白龙马）一直形影不离，后来，我觉得自己找到了答案，那就是唐僧的善良，他传递的这份能量是徒弟们永远达不到的层面，自然而然的形成一种向心力。 04很多时候，我们总是抱怨身边的人是个傻逼，很明显的骗术都看不到，我想他们不是看不到，而是他们在自己的世界里保留了一份真善美。 他们会因为一件小事感动，会第一时间为别人考虑，每每遇到事情，考虑最多的还是别人，生怕自己失误的决策给别人带来致命的打击。 如果陈奕帆没有善良的一幕，或许后面的温情也不会上演；如果小马不善良，那位乞讨者家里或许真会雪上加霜，看不到生活的希望；如果这位企业家一心想着雪耻的话，他的对手或许会家破人亡，原本一个幸福的家庭会在顷刻间化为乌有。 记得以前看过一个小品，里面有一句话：“如果人摔倒了，都没有人扶，时间久了当人心倒了，那就真扶不起来了”。 其实有时候，很多人比我们聪明的多，但他们却宁愿做一个善良的傻子。 ◆作者：林子树，曾做过报社记者，媒体期刊写手，作品多见《知音》《家庭》《华西都市报》《青年文摘》《读者》《环球人物》《意林》等，微信公众账号：lovesteey2。文章首发写手圈（xieshouquan010)，爱写作的人都在这里。","tags":[{"name":"感悟","slug":"感悟","permalink":"http://summer.com/tags/感悟/"}]},{"title":"Markdown语法学习","date":"2017-02-22T13:52:27.000Z","path":"2017/02/22/Markdown语法/","text":"之前项目文档师兄都是用Markdown语法来写的，一直想系统地看看其语法，结果一直没行动起来，正好今晚整理博客，就想着看看，整理一下。（发现自己的拖延症真的要严重） 标题设置在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。如：12345这是一级标题=========这是二级标题--------- (Markdown会自动把每行前面空四格的文本转换为代码块)=和-的个数无要求第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 斜体和粗体斜体：两端使用1个”*“或者”_“夹起来粗体：两端使用2个”*“或者”_“夹起来1234*斜体*或者_斜体_**粗体*****加粗斜体***~~删除线~~ 效果如下：斜体或者斜体粗体加粗斜体删除线 超链接Markdown支持两种方式的超链接，行内式和参考式，其中行内式用的比较多 行内式12[链接文字](链接地址)[链接文字](链接地址 &quot;链接标题&quot;) 链接标题可加可不加，只是鼠标悬停在地址上，会显示的文字 参考式参考式链接主要用于以下场景，比如学术论文里或者是多次引用该地址 我经常去的几个网站[Google][1]、[Leanote][2]，[Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com &quot;Google&quot; [2]:http://www.leanote.com &quot;Leanote&quot; [网站]:http://http://blog.leanote.com/freewalk 自动链接有时候我们会想直接把链接地址显示出来，比如想直接把我的博客地址展示，可以通过&lt;https://ily11.github.io/&gt;直接用&lt;&gt;包起来的方式展示。 列表无序列表使用 *，+，- 表示无序列表。 有序列表有序列表则使用数字接着一个英文句点。 解释型列表第一行写定义，然后下一行有一个冒号和四个空格，如果要引入代码块，就是八个空格 Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 : 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 引用一般引用就是用“&gt;”加一个空格即可，当然也可以嵌套引用，即用多个“&gt;”实现嵌套引用。引用代码的话，只要在“&gt;”+空格后再加4个空格即可 插入图像插入图像跟超链接一样都是有两种方式，而且类似，其一般格式是:![图片Alt](图片地址 &quot;图片Title&quot;)语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 代码行内插入短代码，可以直接用Tab键下的符号来包裹代码，如果是多行代码，可以用4个空格，Markdown会自动识别前面有4个空格的为代码块，直到没有4个空格为止，还可以用6个Tab键下的符号，前面三个，后面三个包裹起来。 表格12345Title|Data|tags-|-|-aaaa|2017-1-20|cssbbbb|2016-12-20|jscccc|2016-10-11|html 效果如下： Title Data tags aaaa 2017-1-20 css bbbb 2016-12-20 js cccc 2016-10-11 html 表格写法要在前面空一行","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://summer.com/tags/Markdown/"}]},{"title":"我的第一篇博客","date":"2017-02-07T07:34:27.000Z","path":"2017/02/07/我的第一篇博客/","text":"一直想有属于自己的博客，前些日子师姐教我可以用hexo搭建自己的博客，现在终于有时间写自己的第一篇博客了。以下总结了我在搭建博客遇到的一些问题：1、在github新建仓库的时候仓库名一定要与用户名一致；2、在本地运行博客的时候，如果自己电脑安装了福昕阅读器的话，4000端口是被其占用的，需要用命令 hexo s -p 5000 调整到5000端口；3、为自己的博客添加头像： #你的头像urlavatar: /img/blog.jpg 将图片放在主题文件夹下的source下的img文件夹即可，然后在avatar引用，当然也可以用网络地址引用。总之搭建步骤： 安装好node和git，注册号github账号 安装hexo $ npm install -g hexo-cli 创建hexo文件夹并安装依赖 $ hexo init $ cd $ npm install 完成本地安装 $ hexo generate$ hexo server 发布到github上 hexo generatehexo deploy 一些常用命令： hexo new “postName” //新建文章 hexo new page “pageName” //新建页面 hexo generate //生成静态页面至public目录 hexo server //开启本地预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy //将.deploy目录部署到GitHub 问题： 问题1: Error: Cannot find module ‘hexo-util’回答1：npm install – save-dev hexo-util 问题2: sh: 1: cannot create highlight_alias.json: Permission denied回答2: 尝试执行npm config set unsafe-perm true，依然不行按照官方解决方案尝试https://docs.npmjs.com/getting-started/fixing-npm-permissions 问题3：想把自己搭建博客原文件上传到github上，结果发现theme下的next文件夹里的文件上传不上去，原因是该主题有其他的github在维护回答3：进入无法提交的文件夹下，运行rm -rf .git,删除隐藏的git文件，然后在返回根目录重新提交。 即可通过https://ily11.github.io/访问博客Next的主题文件的配置可以参照 官方文档 进行配置","tags":[]}]